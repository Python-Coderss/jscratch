# Java-based Scratch-like Web Application with Python Block Support

## Project Description

This project is a web application that provides a simplified, Scratch-like visual programming environment. Users can drag and drop blocks (including custom Python code blocks) to an assembly area to create simple programs. The frontend is built with HTML, CSS, and vanilla JavaScript, while the backend is a lightweight Java HTTP server responsible for executing the programs. Python code blocks are executed using an embedded Jython interpreter.

The primary goal is to explore the integration of a visual block metaphor with Python scripting, executed server-side, and to build a foundation for more complex block-based programming.

## Features (Current State)

*   **Web-Based Interface:** Accessible via a modern web browser with a tabbed interface ("Scripts", "Costumes", "Sounds").
*   **Basic Sprite System:**
    *   A default "Sprite1" is created on application startup (both client and server-side conceptual model).
    *   Scripts, costumes, and sounds are managed in the context of this active sprite.
    *   A "Sprites" panel displays the list of sprites (currently just "Sprite1") and allows selection.
*   **Visual Stage:**
    *   A 480x360 pixel stage area where sprites are rendered.
    *   Sprites display their current costume at their X, Y coordinates ((0,0) is center, Y positive is up, similar to Scratch).
*   **Scripts Tab:**
    *   **Three-Panel Layout:** Block Palette, Script Assembly Area, and Stage Area (text output).
    *   **Drag-and-Drop Interface:** Blocks can be dragged from the palette to the script assembly area for the active sprite, allowing vertical stacking.
    *   **Block Configuration & Types:**
        *   **Python Code Block:** Opens a modal for Python code input. Executed server-side using an embedded Jython interpreter.
        *   **Say Block (Looks):** Prompts for text. Server simulates a "say" action, output in Stage.
        *   **Loop Block (Control):** Prompts for a count. Rendered with a visual placeholder for nested blocks (execution of children not yet implemented).
        *   **Go to X: Y: Block (Motion):** Prompts for X and Y coordinates. Affects the active sprite's position on the stage.
        *   **Switch to costume: Block (Looks):** Prompts with available costumes for the active sprite. Changes the sprite's appearance on the stage.
    *   **Multi-Block Script Execution:** The frontend sends a JSON array of the active sprite's blocks to the server. The server parses this and executes blocks sequentially.
    *   **Aggregated Text Output:** Output from all executed blocks is displayed in the "Stage Area's" text output section.
*   **Basic Variable System:** Create global or sprite-local variables via a UI dialog (name, scope).
*   **Variable Blocks:** 'Set [Variable] to [Value]' and 'Change [Variable] by [Value]' blocks for modifying variables.
*   **Variable Reporters:** Created variables appear as draggable reporter blocks in a 'Variables' palette category.
*   **Stage Monitors:** Variables can be toggled for display on the stage, showing their name and current value. Monitors update optimistically during script execution.
*   **Costumes Tab (per Sprite):**
    *   **Client-Side Asset Handling:** Allows users to select local image files for the active sprite.
    *   Thumbnails are displayed. Clicking a thumbnail sets it as the `currentCostumeId` for the active sprite and updates the stage.
*   **Sounds Tab (per Sprite):**
    *   **Client-Side Asset Handling:** Allows users to select local audio files for the active sprite.
    *   Sounds are listed with a "Play" button for in-browser playback.
*   **Server-Side Operations:**
    *   Java HTTP server for static files and API requests.
    *   Server-side logging (`server.log`).
*   **Basic Script Runner (Legacy):** Retains a `/run/<script_name>` endpoint.

## Directory Structure

-   `src/main/java/com/example/SimpleHttpServer.java`: The core Java code for the backend HTTP server, including request handlers.
-   `src/main/java/com/example/JythonExecutor.java`: Class responsible for executing Python code using the embedded Jython interpreter.
-   `webapp/`: Contains all frontend files (`index.html`, `style.css`, `js/app.js`).
-   `scripts/`: Holds example shell scripts for the legacy `/run/` endpoint.
-   `lib/`: This directory is for JAR dependencies. **You must create this directory and place the required JARs (Jython Standalone and Org.JSON) here.**
-   `server.log`: Log file generated by the Java server.
-   `out/` (Optional, created during build): Default directory for compiled Java class files.
-   `DESIGN_NOTES.md`: Contains conceptual details about program execution architecture and sandboxing.

## Prerequisites

*   **Java JDK 8 or higher:** Required to compile and run the Java server code.
*   **Jython Standalone JAR:** Required for executing Python blocks from the web UI.
*   **Org.JSON JAR:** Required by the server to parse JSON data sent from the frontend.
*   **Python 3 Interpreter (Optional, for legacy script runner):** If you intend to use the `/run/<script_name>` endpoint with Python scripts that require CPython, it must be in the system's PATH. This is **not** used for Python blocks added via the UI.
*   **Web Browser:** A modern web browser to access the application.

### Dependency Setup (`lib/` directory)

The Java server relies on external JAR files. These need to be manually downloaded and placed in a `lib/` directory within the project root.

1.  **Create `lib` Directory:** If it doesn't already exist, create a directory named `lib` in the root of this project.
2.  **Download Jython Standalone JAR:**
    *   Go to the [Jython official website](https://www.jython.org/download).
    *   Download the "Jython Standalone" JAR file (e.g., `jython-standalone-2.7.3.jar`). Replace `2.7.3` with your downloaded version in commands below.
    *   Place this JAR into the `lib/` directory.
3.  **Download Org.JSON JAR:**
    *   Go to the [Maven Central Repository Search](https://search.maven.org/search?q=g:org.json%20AND%20a:json).
    *   Select a recent version (e.g., `20231013`). Replace `20231013` with your downloaded version in commands below.
    *   Download the JAR file (e.g., `json-20231013.jar`).
    *   Place this JAR into the `lib/` directory.

**After setup, your `lib/` directory should contain at least:**
*   `jython-standalone-X.Y.Z.jar` (e.g., `jython-standalone-2.7.3.jar`)
*   `json-YYYYMMDD.jar` (e.g., `json-20231013.jar`)

## How to Build and Run

1.  **Ensure `lib` directory and the Jython & JSON JARs are set up as described above.** Remember to replace version numbers in commands with the actual versions you downloaded.
2.  **Compile the Java Server:**
    Open a terminal or command prompt, navigate to the project's root directory. Create an `out` directory if it doesn't exist (`mkdir -p out`). Then, run the compilation command:

    *   **Linux/macOS (colon classpath separator):**
        ```bash
        javac -cp "lib/jython-standalone-2.7.3.jar:lib/json-20231013.jar" -d out src/main/java/com/example/*.java
        ```
    *   **Windows (semicolon classpath separator):**
        ```bash
        javac -cp "lib\jython-standalone-2.7.3.jar;lib\json-20231013.jar" -d out src\main\java\com\example\*.java
        ```
    *(Note: The server will not function correctly without these JARs and the correct classpath setup. Ensure you use the correct JAR filenames for the versions you downloaded.)*

3.  **Run the Java Server:**
    After successful compilation, run the server using:

    *   **Linux/macOS:**
        ```bash
        java -cp "lib/jython-standalone-2.7.3.jar:lib/json-20231013.jar:out" com.example.SimpleHttpServer
        ```
    *   **Windows:**
        ```bash
        java -cp "lib\jython-standalone-2.7.3.jar;lib\json-20231013.jar;out" com.example.SimpleHttpServer
        ```
    The server will start, and you should see log messages in your console (and in `server.log`) indicating it's running on port 8000.

4.  **Access the Application:**
    Open your web browser and navigate to:
    `http://localhost:8000/`

## How to Use (Current Functionality)

1.  **Open the Application:** Navigate to `http://localhost:8000/` in your browser. The "Scripts" tab is active by default. A default "Sprite1" is automatically created and selected.

2.  **Sprite Context:**
    *   The "Sprites" panel (usually below the stage or main content area) lists available sprites. Currently, only "Sprite1" exists.
    *   All script blocks added, costumes uploaded, and sounds uploaded are associated with the currently **active sprite** (which is "Sprite1" by default).

3.  **Working with the "Scripts" Tab (for the active sprite):**
    *   **Adding Blocks:** Drag blocks ("Python Code Block", "Say Block", "Loop Block", "Go to X: Y:", "Switch to costume:") from the "Block Palette" (left panel) to the "Script Assembly Area" (middle panel). Blocks will be added to the script of the active sprite.
    *   **Configuring Blocks:**
        *   **Python Code Block:** On drop, a modal appears. Enter Python code, click "Save Python."
        *   **Say Block:** On drop, a prompt appears. Enter text to "say," click "OK."
        *   **Loop Block:** On drop, a prompt appears. Enter repetitions (e.g., 3), click "OK."
        *   **Go to X: Y: Block:** On drop, prompts for X then Y coordinates. Enter numbers, click "OK." This affects the active sprite's position on the Stage.
        *   **Switch to costume: Block:** On drop, a prompt lists available costumes for the active sprite (by name/ID). Enter the name or ID of the desired costume. This changes the active sprite's appearance on the Stage. (Upload costumes first via the "Costumes" tab).
    *   **Viewing Assembled Program:** Blocks appear stacked in the "Script Assembly Area."
    *   **Running the Program:** Click the "Run Program" button. This executes the script for the active sprite.
    *   **Viewing Output & Stage:** Text output appears in the text area below the stage. Visual changes (sprite position, costume) occur on the stage.

4.  **Working with Variables (for the active sprite):**
    *   **Making Variables:** Click the "Make a Variable" button in the "Variables" category of the Block Palette. A dialog will appear.
        *   Enter a variable name (letters, numbers, underscores; must start with a letter or underscore).
        *   Choose the scope: "For all sprites (global)" or "For this sprite only" (local to the active sprite).
        *   Click "OK".
    *   **Variable Reporters in Palette:** Newly created variables appear as draggable reporter blocks in the "Variables" category. Global variables are shown by name (e.g., `myGlobalVar`). Local variables are prefixed with the sprite name (e.g., `Sprite1:myLocalVar`).
    *   **Stage Monitors:** Next to each variable reporter in the palette is a checkbox. Check this box to display the variable's name and current value as a "monitor" on the stage. Uncheck to hide it. Monitors update in real-time during script execution (based on client-side optimistic updates).
    *   **Using "Set [Variable] to [Value]" Block:**
        *   Drag this block from the "Variables" category to the script assembly area.
        *   A prompt will ask you to select the variable to set (by its display name or ID from a list of available global and active sprite's local variables).
        *   A second prompt will ask for the value to set it to. Currently, this must be a literal value (number, text, true/false).
    *   **Using "Change [Variable] by [Value]" Block:**
        *   Drag this block to the script assembly area.
        *   A prompt will ask you to select the variable to change.
        *   A second prompt will ask for the numeric value to change it by (e.g., `1`, `-5`). If the variable currently holds a non-numeric value, it's treated as `0` before the change. If the variable doesn't exist, it's created with a value of `0` before the change.

5.  **Working with the "Costumes" Tab (for the active sprite):**
    *   Select the "Costumes" tab.
    *   Click "Choose Files" to select local image files.
    *   Thumbnails appear. Clicking a thumbnail sets it as the active sprite's current costume, updating its appearance on the Stage.

5.  **Working with the "Sounds" Tab (for the active sprite):**
    *   Select the "Sounds" tab.
    *   Click "Choose Files" to select local audio files.
    *   Sounds are listed with a "Play" button. Click to play.

## Testing

Automated JavaScript UI testing (e.g., with Jest) was explored. However, due to current execution environment limitations preventing the installation of Node.js packages or running test runners, this is not feasible at this time.

Manual testing is the current approach for verifying frontend and integration functionality. Detailed manual test cases can be found in [TESTING.md](TESTING.md).

## Known Issues & Limitations

*   **Backend Sprite Targeting:** Backend execution for "Go to X:Y:" and "Switch to costume:" blocks currently targets a hardcoded "sprite1". True multi-sprite execution context (knowing which sprite's script is running and applying actions to *that specific* sprite on the backend) is not yet fully implemented.
*   **Client-Side Optimistic Updates:** Sprite position and costume changes are shown immediately on the frontend (optimistic update). The server updates its state for "sprite1". The server's response is an aggregated log; it does not yet send back the authoritative full state of all sprites.
*   **Sprite Management UI:** Only a single, default "Sprite1" is created at startup. There is no UI for adding new sprites, deleting existing ones, or renaming them.
*   **Asset Persistence & Scope:** Costumes and Sounds are client-side only (using Data URLs, stored in JavaScript arrays per sprite for the session). They are not saved on the server or persisted if the page is refreshed.
*   **Drag-and-Drop Limitations:** Currently supports adding blocks to the end of the active sprite's script. Reordering or deleting blocks is not yet implemented.
*   **Nesting Implementation:** The Loop block has a visual placeholder for nested blocks, but dropping blocks *into* it or executing nested logic is not yet functional.
*   **Loop Block Execution:** Backend execution for Loop blocks is a placeholder; it acknowledges the loop and its count but does not execute child blocks.
*   **No Block Editing After Placement:** Configured blocks in the assembly area cannot be directly edited.
*   **Variable Reporter Blocks as Inputs:** Using a variable reporter block as an input to another block (e.g., `Set [var1] to [var2]`) is supported by the backend if the JSON is structured correctly, but the UI does not yet allow visually dragging and dropping reporters into input slots of other blocks. Current block input prompts only accept literal values.
*   **Stage Monitor Synchronization:** Stage monitors reflect client-side optimistic updates. The server's response is an aggregated log; no full variable state is sent back to synchronize after execution (though the server state *is* updated).
*   **No State Persistence:** The entire project state (sprites, scripts, assets, variables) is lost on page refresh.

## Future Ideas

*   Implement execution of child blocks within Loop blocks.
*   Allow editing and deletion of blocks in the assembly area.
*   Implement drag-and-drop reordering of assembled blocks.
*   Support for more "Standard Blocks" (e.g., variables, simple math, conditional logic).
*   Visual feedback for connections between blocks.
*   Saving and loading user-created programs.

## Design and Architecture

The current execution model for code submitted from the web UI (via the `/api/execute_program` endpoint) uses a JSON array payload to define the program (a sequence of blocks). Python code blocks are run using Jython directly within the Java server, and standard blocks like "Say" are handled by specific Java logic. The backend iterates through this array to process the blocks.

For a more Scratch-like experience with advanced features like nested execution in loops and more complex block interactions, a more comprehensive program execution architecture is being developed.

Detailed conceptual notes on this program execution architecture, including JSON structure, block type handling, state management, and sandboxing, can be found in [DESIGN_NOTES.md](./DESIGN_NOTES.md).
